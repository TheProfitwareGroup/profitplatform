var
    url = require('url'),
    appsrvi = require('core/appsrv.js'),
    appsrv = new appsrvi(__filename),
    rpc = require('core/rpc.js'),
    jsonrpc = require('core/jsonrpc.js'),
    view = require('./view.js'),
    Sync = require('sync'),
    uuid = require('node-uuid'),
    path = require('path'),
    sprintf = require('sprintf').sprintf,
    options = require('options.js');

Array.prototype.find = function (key, value) {
    var ret = {};
    this.forEach(function (param) {
        if (param[key] == value)
            ret = param;
    });
    return ret;
};

Array.prototype.pFind = function (page) {
    return this.find('page', page).vars;
};

Array.prototype.pathFind = function (path) {
    var sMenus = this;
    var p = [
        {href: '#index', title: 'Главная'}
    ];
    if (path == 'index')
        return p;
    for (var n = 0; n < sMenus.length; n++) {
        var x = sMenus[n].menu;
        for (var t = 0; t < x.length; t++) {
            if (/(\w+)\.?/.exec(path)[1] == x[t]._path) {
                p.push({title: x[t].title, href: x[t].href});
                var z = x[t].menu;
                if (z != undefined)
                    for (var i = 0; i < z.length; i++) {
                        if (z[i]._path == path)
                            p.push({href: z[i].href, title: z[i].name});
                    }
            }
        }
    }
    return p;
};

render = function (req, res, next) {
    var err404 = false;
    var out = function (err, data) {
        if (err404)
            res.statusCode = 404;
        res.setHeader("Content-Type", "text/html; charset=UTF-8");
        if (err || (data === undefined)) {
            res.write('Internal error ' + err.toString());
        } else {
            res.write(data);
        }
        res.end();
    };
    Sync(function () {
        var parsedUrl = url.parse(req.url, true),
            sess = req.session,
            denied = false,
            pageStructure = view.main.sync(view, sess),
            lPage;
        if (sess.lastPage != undefined) {
            lPage = sess.lastPage.substring(1);
            if ((lPage == '') || (lPage == 'logout'))
                lPage = 'index';
            pageStructure.pFind('content').lastPage = '#' + lPage;
        }
        if (parsedUrl.pathname == '/logout')
            parsedUrl.pathname = '/';
        lPage = parsedUrl.pathname.substring(1);
        if (/\/eventflow\.docs_new\//.test(parsedUrl.pathname) && parsedUrl.pathname != '/eventflow.docs_new') {
            parsedUrl.pathname = '/eventflow.docs_new';
            lPage = 'eventflow.docs_new';
            if (req.params.docname)
                sess.docname = req.params.docname;
        } else {
            sess.docname = undefined;
        }
        if (/\/eventflow\.docs_in\//.test(parsedUrl.pathname) && parsedUrl.pathname != '/eventflow.docs_in') {
            parsedUrl.pathname = '/eventflow.docs_in';
            lPage = 'eventflow.docs_in';
            if (req.params.ref)
                sess.ref = req.params.ref;
        } else {
            sess.ref = undefined;
        }
        lPage = lPage == '' ? 'index' : lPage;
        sess.lastPage = parsedUrl.pathname;
        pageStructure.pFind('topnav').page = pageStructure.pFind('content').page = parsedUrl.pathname;
        pageStructure.pFind('content').year = new Date().getFullYear().toString();
        var pth = [pageStructure.pFind('topnav'), pageStructure.pFind('leftmenu')].pathFind(lPage);
        if (lPage == 'eventflow.docs_new' && sess.docname) {
            pth.push({ href: '#eventflow.docs_new/' + sess.docname, title: sess.docname });
        }
        if (lPage == 'eventflow.docs_in' && sess.ref) {
            pth.push({ href: '#eventflow.docs_in/' + sess.ref, title: sess.ref });
        }
        pageStructure.pFind('content').path = appsrv.page.sync(appsrv, 'path', {path: pth});
        pageStructure.pFind('topnav').loginname = (sess.loginname != undefined) ? sess.loginname : '';
        pageStructure.pFind('content').auth = (pageStructure.pFind('topnav').loginname != '');
        pageStructure.pFind('content').ajax = parsedUrl.query.ajax != undefined;
        switch (parsedUrl.pathname) {
            case '/':
                ;
            case '/index':
                pageStructure.pFind('topnav').menu.find('id', 'index').active = true;
                break;
            case '/about':
                pageStructure.pFind('topnav').menu.find('id', 'about').active = true;
                pageStructure.pFind('content').content = appsrv.page.sync(appsrv, 'about');
                break;
            case '/leftmenu':
                if (parsedUrl.query.ajax == undefined || !pageStructure.pFind('content').auth) {
                    denied = true;
                    break;
                }
                pageStructure.pFind('content').content = appsrv.page.sync(appsrv, 'leftmenu', pageStructure.pFind('leftmenu'));
                pageStructure.pFind('err403').content = appsrv.page.sync(appsrv, 'err403');
                break;
            default:
                if (!pageStructure.pFind('content').auth) {
                    denied = true;
                    break;
                }
                try {
                    pageStructure = require(path.normalize(path.join('app', 'eventflow', 'schema', parsedUrl.pathname) + '.js'))({
                        pageStructure: pageStructure,
                        sess: sess,
                        parsedUrl: parsedUrl,
                        appsrv: appsrv
                    });
                } catch (e) {
                    console.log(e);
                }
                break;
        }
        ;

        if (denied && pageStructure.pFind('content').auth == false) {
            pageStructure.pFind('content').content = appsrv.page.sync(appsrv, 'err403');
        }
        //console.log('denied ' + denied);
        //console.log('auth ' + pageStructure.pFind('content').auth);
        //console.log('content ' + pageStructure.pFind('content').content);
        var x;
        if (parsedUrl.query.ajax != undefined) {
            x = appsrv.page.sync(appsrv, 'content', pageStructure.pFind('content'));
        } else {
            var pages = appsrv.renderAll.sync(appsrv, pageStructure);
            pages.auth = pageStructure.pFind('content').auth;
            pages.ajax = pageStructure.pFind('content').ajax;
            x = appsrv.page.sync(appsrv, 'index', pages);
        }
        return x;
    }, out);
};

login = function (req, res, next) {
    var resJSON = {
        state: 'fail'
    };
    var out = function (err, data) {
        res.setHeader("Content-Type", "application/json; charset=UTF-8");
        res.write(JSON.stringify(resJSON));
        res.end();
    };
    Sync(function () {
        var apikey = req.session.apikey,
            login = req.body.login,
            pwd = req.body.pwd;
        if (apikey == undefined)
            apikey = '';
        r = new RegExp(/\w+/);
        if (r.test.apply(r, [login, pwd])) {
            var n = rpc.local.sync(rpc, 'platform.common.getsession', [apikey, login, pwd]);
            var loginS = rpc.local.sync(rpc, 'platform.admin.getinfo', [n]);
            login = loginS.user[0].name + ' ' + loginS.user[0].surname;
            resJSON = {
                state: 'success',
                loginname: login
            };
            req.session.user = loginS.user[0];
            req.session.loginname = login;
            req.session.newref = uuid.v4();
            req.session.apikey = n;
        }
    }, out);
};

logout = function (req, res, next) {
    out = function (err, obj) {
        return render(req, res, next);
    };
    Sync(function () {
        var apikey = req.session.apikey;
        if (apikey != undefined) {
            try {
                var x = rpc.local.sync(rpc, 'platform.common.deletesession', [apikey]);
                req.session.apikey = '';
                req.session.loginname = '';
            } catch (e) {
            }
        }
    }, out);
};

checkapikey = function (req, res, next) {
    var resJSON = { session: 'ok' };
    var out = function (err, data) {
        res.setHeader("Content-Type", "application/json; charset=UTF-8");
        res.write(JSON.stringify(resJSON));
        res.end();
    };
    Sync(function () {
        var apikey = req.session.apikey;
        if (apikey != undefined) {
            try {
                var x = rpc.local.sync(rpc, 'platform.common.checksession', [apikey]),
                    parsedUrl = url.parse(req.url, true),
                    sess = req.session;
                if (parsedUrl.pathname == '/docs_new' && sess.newref && sess.docname == parsedUrl.query.doctype) {
                    var document = {},
                        fulldoc = {},
                        doc = rpc.local.sync(rpc, 'app.eventflow.web.doctype.find', [apikey, {}]),
                        docfields = doc.find('name', sess.docname).fields,
                        checked = true,
                        docstate = {};
                    docfields.forEach(function (field) {
                        if (field.name && parsedUrl.query[field.name] && (field.type != 'in')) {
                            if (field.regex && field.regex.test) {
                                var rok = new RegExp(field.regex).test(parsedUrl.query[field.name]);
                                if (!rok) {
                                    var msg = sprintf('<div class="alert alert-error fade in"><a class="close" data-dismiss="alert">×</a>Поле &quot;%s&quot; должно соответствовать регулярному выражению %s</div>', field.title, field.regex);
                                    if (resJSON.message) {
                                        resJSON.message = resJSON.message + msg;
                                    } else {
                                        resJSON.message = msg;
                                        resJSON.docstatus = 'error';
                                    }
                                } else
                                    document[field.name] = parsedUrl.query[field.name];
                                checked = checked && rok;
                            } else
                                document[field.name] = parsedUrl.query[field.name];
                        }
                    });
                    if (!checked)
                        return;
                    fulldoc = {
                        sysid: sprintf('EventFlow [ProfitPlatform %s] (%s:%s)',
                            options.version, options.platform_host, options.platform_port),
                        ref: sess.newref,
                        history: [],
                        status: 'created',
                        date_ts: new Date(),
                        doctype: sess.docname,
                        document: document
                    };
                    docstate = rpc.local.sync(rpc, 'app.eventflow.document.add', [sess.apikey, fulldoc]);
                    resJSON.docref = docstate.ref;
                    resJSON.docstatus = docstate.status;
                    sess.newref = uuid.v4();
                }
                if (parsedUrl.pathname == '/docs_push' && sess.ref) {
                    var docstate = rpc.local.sync(rpc, 'app.eventflow.dispatch.push', [sess.apikey, { ref: sess.ref}]);
                    resJSON.docref = docstate.ref;
                    resJSON.docstatus = docstate.status;
                    if (docstate.error)
                        resJSON.message = docstate.error;
                }
            } catch (e) {
                if (e == jsonrpc.NEED_RELOGIN) {
                    resJSON.session = 'need_relogin';
                } else {
                    resJSON.session = 'invalid_apikey';
                }
                req.session.apikey = undefined;
                req.session.loginname = '';
            }
        } else {
            resJSON.session = 'no_apikey';
        }
    }, out);
};

app = function (app) {
    ['/',
        '/index',
        '/about',
        '/platform.stats',
        '/platform.profile',
        '/platform.settings',
        '/eventflow.docs_new',
        '/eventflow.docs_new/:docname',
        '/eventflow.docs_in',
        '/eventflow.docs_in/:ref',
        '/leftmenu'
    ].forEach(function (path) {
            return app.get(path, render);
        });
    app.post('/login', login);
    app.get('/logout', logout);
    ['/checkapikey',
        '/docs_new',
        '/docs_push'
    ].forEach(function (path) {
            return app.get(path, checkapikey);
        });
};

module.exports = exports = app;