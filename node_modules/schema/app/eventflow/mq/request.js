var
    schema = require('core/schema.js').initme(__filename),
    zmq = require('zmq'),
    Sync = require('sync'),
    sprintf = require('sprintf').sprintf,
    rpc = require('core/rpc.js'),
    l = require('core/logger.js'),
    db = require('core/db.js');

var
    timeout = 500,
    mq_sysidX = 'ZeroMQ',
    m_name = 'app.eventflow.mq.request';

var main = {};

main[schema] = function (apikey, document, servers, result) {
    var
        closed = false,
        mq_sysid = '';
    var req = zmq.socket('req');
    if (typeof servers == 'string') {
        req.connect(servers);
        mq_sysid = sprintf('%s at %s', mq_sysidX, servers);
    } else {
        servers.forEach(function (server) {
            req.connect(server);
        });
        mq_sysid = sprintf('%s at [%s]', mq_sysidX, servers.join(', '));
    }
    Sync(function () {
        var data = {};
        var doc = rpc.local.sync(rpc, 'app.eventflow.document.status', [apikey, document]);
        if (doc.status != 'error') {
            var doc = db.emit.sync(db, 'schema', '[app.eventflow]document.find', doc);
            doc.status = 'pending';
            doc.history.push({
                sysid: mq_sysid,
                status: 'pending',
                date_ts: new Date()
            });
            data = doc.document;
            if (db.emit.sync(db, 'schema', '[app.eventflow]document.add', doc)) {
                if (typeof data == 'string')
                    req.send(data);
                else
                    req.send(JSON.stringify(data));
            } else {
                throw sprintf('adding document %s failed', doc.ref);
            }
        }
        return data;
    }, function (err, obj) {
        if (err)
            l.error(m_name, sprintf('Error sending document %s to %s', obj, mq_sysid));
        else
            l.trace(m_name, sprintf('Document %s sent to %s', obj, mq_sysid));
    });
    setTimeout(function () {
        Sync(function () {
            if (!closed) {
                l.warning(m_name, sprintf('Timeout receiving message from %s', mq_sysid))
            }
            return rpc.local.sync(rpc, 'app.eventflow.document.status', [apikey, document]);
        }, result);
    }, timeout);
    req.on('message', function (msg) {
        Sync(function () {
            var doc = rpc.local.sync(rpc, 'app.eventflow.document.status', [apikey, document]);
            if (doc.status != 'error') {
                var fields = {};
                var doc = db.emit.sync(db, 'schema', '[app.eventflow]document.find', doc);
                try {
                    var newdoc = JSON.parse(msg.toString());
                    for (var i in newdoc) {
                        if (doc.document[i])
                            fields[i] = doc.document[i];
                        doc.document[i] = newdoc[i]
                    }
                } catch (e) {
                    if (doc.document.data)
                        fields.data = doc.document.data;
                    doc.document.data = msg.toString();
                }
                doc.status = 'processed';
                doc.history.push({
                    sysid: mq_sysid,
                    status: 'processed',
                    date_ts: new Date(),
                    fields: fields
                });
                var success = false;
                if (db.emit.sync(db, 'schema', '[app.eventflow]document.add', doc))
                    success = true;
                return { ref: doc.ref, success: success };
            }
        }, function (err, obj) {
            if (err) {
                l.error(m_name, 'Error receiving document: %s', err);
            } else {
                l.trace(m_name, sprintf('Document %s processed %ssuccessfully from %s', obj.ref, obj.success ? '' : 'un', mq_sysid));
                closed = true;
            }
            req.close();
        });
    });
};

exports.main = main;
