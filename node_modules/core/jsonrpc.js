
/*!
 * Ext JS Connect
 * Copyright(c) 2010 Sencha Inc.
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var l = require('core/logger.js'),
	parse = require('url').parse,
    http = require('http'),
    validator = require('core/validator.js'),
    
    db = require('core/db.js'),
    access = require('core/access.js');

/**
 * Export the `setup()` function.
 */

exports = module.exports = jsonrpc;

/**
 * JSON-RPC version.
 */

var VERSION = exports.VERSION = '2.0';

/**
 * JSON parse error.
 */

var PARSE_ERROR = exports.PARSE_ERROR = -32700;

/**
 * Invalid request due to invalid or missing properties.
 */

var INVALID_REQUEST = exports.INVALID_REQUEST = -32600;

/**
 * Service method does not exist.
 */

var METHOD_NOT_FOUND = exports.METHOD_NOT_FOUND = -32601;

/**
 * Invalid parameters.
 */

var INVALID_PARAMS = exports.INVALID_PARAMS = -32602;

/**
 * Internal JSON-RPC error.
 */

var INTERNAL_ERROR = exports.INTERNAL_ERROR = -32603;

/**
 * Invalid credentials.
 */

var INVALID_CREDENTIALS = exports.INVALID_CREDENTIALS = 9001;

/**
 * Invalid apikey.
 */

var INVALID_APIKEY = exports.INVALID_APIKEY = 9002;

/**
 * Bad number of parameters.
 */


var BAD_NUMBER_OF_PARAMETERS = exports.BAD_NUMBER_OF_PARAMETERS = 9003;

/**
 * Access prohibited.
 */

var ACCESS_PROHIBITED = exports.ACCESS_PROHIBITED = 9004;

/**
 * Need relogin.
 */

var NEED_RELOGIN = exports.NEED_RELOGIN = 9005;


/**
 * Database connection error.
 */

var DATABASE_CONNECTION_ERROR = exports.DATABASE_CONNECTION_ERROR = 9101;

/**
 * Database error.
 */

var DATABASE_ERROR = exports.DATABASE_ERROR = 9102;

/**
 * Message queue connection error.
 */

var MQ_CONNECTION_ERROR = exports.MQ_CONNECTION_ERROR = 9201;

/**
 * Message queue error.
 */

var MQ_ERROR = exports.MQ_ERROR = 9202;


/**
 * Default error messages.
 */


var errorMessages = exports.errorMessages = {};
errorMessages[PARSE_ERROR] = 'Parse Error.';
errorMessages[INVALID_REQUEST] = 'Invalid Request.';
errorMessages[METHOD_NOT_FOUND] = 'Method Not Found.';
errorMessages[INVALID_PARAMS] = 'Invalid Params.';
errorMessages[INTERNAL_ERROR] = 'Internal Error.';

errorMessages[INVALID_CREDENTIALS] = 'Invalid credentials.';
errorMessages[INVALID_APIKEY] = 'Invalid apikey.';
errorMessages[BAD_NUMBER_OF_PARAMETERS] = 'Bad number of parameters.';
errorMessages[ACCESS_PROHIBITED] = 'Access prohibited.';
errorMessages[NEED_RELOGIN] = 'Need to relogin.';
errorMessages[DATABASE_CONNECTION_ERROR] = 'Database connection error.';
errorMessages[DATABASE_ERROR] = 'Database error.';
errorMessages[MQ_CONNECTION_ERROR] = 'Message queue connection error.';
errorMessages[MQ_ERROR] = 'Message queue error.';

/**
 * Accepts any number of objects, exposing their methods.
 *
 * @param {Object} ...
 * @return {Function}
 * @api public
 */

function jsonrpc(services) {
    services = services || {};

    // Merge methods
    for (var i = 0, len = arguments.length; i < len; ++i) {
        var args = arguments[i];
        Object.keys(args).forEach(function (key) {
            services[key] = args[key];
        });
    }
    /**
     * Handle JSON-RPC request.
     *
     * @param  {Object} rpc
     * @param  {Function} respond
     */

    function handleRequest(rpc, respond){
        if (validRequest(rpc)) { // TODO : Add Session identifier check
            var method = services[rpc.method.split('.').join('_')];
            l.trace('core.jsonrpc', 'jsonrpc.handleRequest :: ' + rpc.method + ' :: ' + JSON.stringify(rpc.params));
            if (typeof method === 'function') {
                var params = [],
                    names = method.toString().match(/\((.*?)\)/)[1].match(/[\w]+/g),
                    ptype = typeof rpc.params;
                if (names) {
                    // Unnamed params
                    if (Array.isArray(rpc.params)) {
                        params = rpc.params;
                        if(params.length != (names.length - 1))
                            return respond({ error: { code: BAD_NUMBER_OF_PARAMETERS, message: 'Bad number of params specified. Expecting ' + (names.length - 1) + '.' }});
                    // Named params
                    } else if (ptype === 'object') {
                        for (var i = 0, len = names.length - 1; i < len; ++i) {
                            l.trace('core.jsonrpc', JSON.stringify(rpc.params[names[i]]));
                            params.push(rpc.params[names[i]]);
                        }
                    } else
                        return respond({ error: { code: INVALID_PARAMS, message: 'Parameters must be specified by array or JSON.' }});
                } else {
                        // Function does not have named parameters
                    return respond({ error: { code: INVALID_PARAMS, message: 'This service does not support named parameters.' }});
                }
                // Reply with the given err and result
                function reply(err, result){
                    if (err) {
                        if (typeof err === 'number') {
                            respond({
                                error: {
                                    code: err
                                }
                            });
                        } else {
                            respond({
                                error: {
                                    code: err.code || INTERNAL_ERROR,
                                    message: err.message
                                }
                            });
                        }
                    } else {
                        respond({
                            result: result
                        });
                    }
                }
                // Push reply function as the last argument
                params.push(reply);

                // Invoke the method
                try {
                    (function(self, params){
                        db.emit('schema', 'session.find', {session : params[0]}, function(err, obj){
                            if((err||(obj===null))&&(params[0]!='')&&(rpc.method!='platform.common.checksession')&&(rpc.method!='platform.common.getsession')){
                                respond({ error: { code: INVALID_APIKEY }});  
                            }else{
                                if((params[0]==='')||(rpc.method==='platform.common.checksession')||(rpc.method==='platform.common.getsession'))
                                    lvl = access.LEVEL_AJAX;
                                else{
                                    lvl = obj.user[0].roles;
                            		if(obj.needrelogin){
                            			db.emit('schema', 'session.delete', { session : obj.session }, function(err, obj){
                            				respond({ error: { code: NEED_RELOGIN }});
                            			});
                            		}
                                }
                                if(obj==null||!obj.needrelogin){
	                                db.emit('schema', 'schema.find', {level: lvl}, function(err, obj){
	                                    if(err||(obj===null)){
	                                        respond({ error: { code: INVALID_REQUEST, message : 'FindSchema error.' }});
	                                    }else{
	                                        try{
	                                            l.trace('core.jsonrpc', JSON.stringify(rpc.method) + ';' + JSON.stringify(obj));
	                                            var inFcn = false;
	                                            obj.forEach(function(i){
	                                                inFcn = inFcn || (i == rpc.method);
	                                            });
	                                            if(inFcn){
	                                                method.apply(self, params);
	                                            }else{
	                                                respond({ error: { code: METHOD_NOT_FOUND }});
	                                            }
	                                        }catch(e){
	                                        	console.log(e);
	                                            respond({ error: { code: INVALID_REQUEST }});
	                                        }
	                                    }
	                                });
                                }
                            }
                        });
                    })(this, params);
                } catch (err) {
                    reply(err);
                }
            } else {
                respond({ error: { code: METHOD_NOT_FOUND }});
            }
        } else {
            respond({ error: { code: INVALID_REQUEST }});
        }
    }

    return function jsonrpc(req, res, next) {
        var me = this,
            contentType = req.headers['content-type'] || '';
        if (req.method === 'POST' && contentType.indexOf('application/json') >= 0) {
            var data = '';
            req.setEncoding('utf8');
            req.addListener('data', function(chunk) { data += chunk; });
            req.addListener('end', function() {

                // Attempt to parse incoming JSON string

                try {
                    var rpc = JSON.parse(data),
                        batch = Array.isArray(rpc);
                } catch (err) {
                    return respond(normalize(rpc, { error: { code: PARSE_ERROR }}));
                }

                /**
                 * Normalize response object.
                 */

                function normalize(rpc, obj) {
                    obj.id = rpc && typeof rpc.id === 'number'
                        ? rpc.id
                        : null;
                    obj.jsonrpc = VERSION;
                    if (obj.error && !obj.error.message) {
                        obj.error.message = errorMessages[obj.error.code];
                    }
                    return obj;
                }

                /**
                 * Respond with the given response object.
                 */

                function respond(obj) {
                    var body = JSON.stringify(obj);
                    res.writeHead(200, {
                        'Content-Type': 'application/json',
                        'Content-Length': Buffer.byteLength(body)
                    });
                    res.end(body);
                }

                // Handle requests

                if (batch) {
                    var responses = [],
                        len = rpc.length,
                        pending = len;
                    for (var i = 0; i < len; ++i) {
                        (function(rpc){
                            handleRequest.call(me, rpc, function(obj){
                                responses.push(normalize(rpc, obj));
                                if (!--pending) {
                                    respond(responses);
                                }
                            });
                        })(rpc[i]);
                    }
                } else {
                    handleRequest.call(me, rpc, function(obj){
                        respond(normalize(rpc, obj));
                    });
                }
            });
        } else {
            next();
        }
    };
};

/**
 * Check if the given request is a valid
 * JSON remote procedure call.
 *
 *   - "jsonrpc" must match the supported version ('2.0')
 *   - "id" must be numeric
 *   - "method" must be a string
 *
 * @param  {Object} rpc
 * @return {Boolean}
 * @api private
 */

function validRequest(rpc){
    return rpc.jsonrpc === VERSION
        && typeof rpc.id === 'number'
        && typeof rpc.method === 'string'
        && rpc.params !== undefined
        && validator.checkSchemaAvailability(rpc.method, rpc.params.apikey);
}
